<html>
    <head>
        <title>ShaderLab</title>
        <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
        <script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
        <script type="text/javascript" src="webgl-utils.js"></script>


        <script id="shader-fs" type="x-shader/x-fragment">
            #ifdef GL_ES
            precision mediump float;
            #endif

            vec4 red() {
                return vec4(1.0, 0.0, 0.0, 1.0);
            }

            void main(void) {
                gl_FragColor = red();
            }
        </script>

        <script id="shader-fs2" type="x-shader/x-fragment">
            #ifdef GL_ES
            precision mediump float;
            #endif

            #define M_PI 3.1415926535897932384626433832795

            uniform float u_time;
            uniform float frequency;
            uniform vec3 multiFrequency;

            float calculateFreqz(float _frequency) {
                return u_time * M_PI * _frequency;
            }

            vec4 red() {
                return vec4(abs(sin(calculateFreqz(multiFrequency.x))), abs(sin(calculateFreqz(multiFrequency.y))), abs(sin(calculateFreqz(multiFrequency.z))), 1.0);
            }

            void main(void) {
                gl_FragColor = red();
            }
        </script>

        <script id="shader-fs3" type="x-shader/x-fragment">
            #ifdef GL_ES
            precision mediump float;
            #endif

            uniform vec2 u_resolution;
            uniform vec2 u_mouse;

            void main(void) {
                vec2 st = gl_FragCoord.xy/u_resolution;
                //gl_FragColor = vec4(st.x, st.y, 0.0, 1.0);
                gl_FragColor = vec4(u_mouse.x, u_mouse.y, 0.0, 1.0);
            }
        </script>
        
        <script id="shader-fs4" type="x-shader/x-fragment">
            #ifdef GL_ES
            precision mediump float;
            #endif

            uniform vec2 u_resolution;
            uniform vec2 u_mouse;
            uniform float u_time;

            // Plot a line of Y using a value between 0.0-1.0
            float plot(vec2 st, float pct) {
                return smoothstep(pct-0.02, pct, st.y) - smoothstep( pct, pct+0.02, st.y);
            }

            void main() {
                vec2 st = gl_FragCoord.xy/u_resolution;

                float y = st.x;

                vec3 color = vec3(y);

                // Plot a line
                float pct = plot(st, y);
                color = (1.0-pct)*color+pct*vec3(0.0,1.0,0.0);

                gl_FragColor = vec4(color, 1.0);
            }
        </script>

        <script id="shader-fs5" type="x-shader/x-fragment">
            #ifdef GL_ES
            precision mediump float;
            #endif

            #define PI 3.14159265359

            uniform vec2 u_resolution;
            uniform vec2 u_mouse;
            uniform float u_time;

            float diff_plot = 0.00001;

            // Plot a line of Y using a value between 0.0-1.0
            float plot(vec2 st, float pct) {
                return smoothstep(pct-diff_plot, pct, st.y) - smoothstep( pct, pct+diff_plot, st.y);
            }

            float functionRet(int func_opt, float x)
            {
                if (func_opt == 0) {
                    return x;
                }
                if (func_opt == 1) {
                    return pow(x, 5.0);
                }
                if (func_opt == 2) {
                    return pow(x, 20.0);   
                }
                if (func_opt == 3) {
                    return pow(x, 2.0);
                }
                if (func_opt == 4) {
                    return pow(x, 1.0);
                }
                if (func_opt == 5) {
                    return pow(x, 0.0);
                }
                if (func_opt == 6) {
                    return pow(x, 0.2);
                }
                if (func_opt == 7) {
                    return pow(x, 0.02);
                }
                if (func_opt == 8) {
                    return (exp(x) - 1.0);
                }
                if (func_opt == 9) {
                    return (0.6 * ( -1.0*log(x) + 0.5));
                }
                if (func_opt == 10) {
                    return log(x) + 1.0;
                }
                if (func_opt == 11) {
                    return (0.5 * pow((x-0.5),1.0/5.0) + 0.5);
                }
            }
            

            void main() {
                vec2 st = gl_FragCoord.xy/u_resolution;

                float y = functionRet(11, st.x);

                vec3 color = vec3(y);

                // Plot a line
                float pct = plot(st, y);
                color = (1.0-pct)*color+pct*vec3(0.0,1.0,0.0);
                color = pct*vec3(0.0,1.0,0.0);

                gl_FragColor = vec4(color, 1.0);
            }
        </script>

        <script id="shader-fs6" type="x-shader/x-fragment">
            #ifdef GL_ES
            precision mediump float;
            #endif

            #define PI 3.14159265359

            uniform vec2 u_resolution;
            uniform vec2 u_mouse;
            uniform float u_time;

            float diff_line = 0.01;

            float plot(vec2 st, float pct){
              return  smoothstep( pct-diff_line, pct, st.y) - 
                      smoothstep( pct, pct+diff_line, st.y);
            }

            void main() {
                vec2 st= gl_FragCoord.xy/u_resolution;

                float y = 1.0;
                float diff = 0.001;
                float diff_y = 0.003;
                float center = 0.5;
                float quarter = 0.25;
                float three_quarter = 0.75;

                if ((st.x > quarter - diff) && (st.x < quarter + diff)) {
                    y = 0.7;
                }

                if ((st.x > center - diff) && (st.x < center + diff)) {
                    y = 0.7;
                }

                if ((st.x > three_quarter - diff) && (st.x < three_quarter + diff)) {
                    y = 0.7;
                }

                if ((st.y < center + diff_y) && (st.y > center - diff_y)) {
                    y = 0.7;
                }

                float ans = plot(st, 1.0*sin(st.x*u_time* 5.0));
                vec3 color_bg = vec3(y);

                vec3 aux = ans*vec3(0.0, 1.0, 0.0);

                vec3 color = (1.0 - ans)*color_bg + aux;

                gl_FragColor = vec4(color, 1.0);
            }

        </script>

        <script id="shader-fs-raymarching" type="x-shader/x-fragment">
            #ifdef GL_ES
            precision mediump float;
            #endif

            uniform vec2 u_resolution;
            uniform float u_time;
            uniform vec2 u_mouse;

            float distance_from_sphere(in vec3 p, in vec3 c, float r)
            {
                return length(p - c) - r;
            }

            float map_the_world(in vec3 p)
            {
                //float displacement = sin(5.0 * p.x) * sin(5.0 * p.y) * sin(5.0 * p.z) * 0.25;
                //float displacement = sin(p.x * u_mouse.x* 5.0) * sin(p.y * u_mouse.y*5.0) * cos(p.z * u_mouse.x * 5.0);
                float displacement = sin(5.0 * p.x * u_time/2.0) * sin(5.0 * p.y * u_time/2.0) * sin(5.0 * p.z * u_time/2.0) * 0.25;
                float sphere_0 = distance_from_sphere(p, vec3(0.0), 1.0);

                // Later we might have sphere_1, sphere_2, cube_3, etc...

                return sphere_0 + displacement;
            }

            vec3 calculate_normal(in vec3 p)
            {
                const vec3 small_step = vec3(0.001, 0.0, 0.0);

                float gradient_x = map_the_world(p + small_step.xyy) - map_the_world(p - small_step.xyy);
                float gradient_y = map_the_world(p + small_step.yxy) - map_the_world(p - small_step.yxy);
                float gradient_z = map_the_world(p + small_step.yyx) - map_the_world(p - small_step.yyx);

                vec3 normal = vec3(gradient_x, gradient_y, gradient_z);

                return normalize(normal);
            }

            vec3 ray_march(in vec3 ro, in vec3 rd)
            {
                float total_distance_traveled = 0.0;
                const int NUMBER_OF_STEPS = 32;
                const float MINIMUM_HIT_DISTANCE = 0.001;
                const float MAXIMUM_TRACE_DISTANCE = 1000.0;
               // vec3 color = vec3(1.0);
                for (int i = 0; i < NUMBER_OF_STEPS; ++i) 
                {
                    //color = color = vec3(0.01, 0.01, 0.01);
                    vec3 current_position = ro + total_distance_traveled * rd;

                    float distance_to_closest = map_the_world(current_position);

                    if (distance_to_closest < MINIMUM_HIT_DISTANCE) 
                    {
                        vec3 normal = calculate_normal(current_position);

                        // For now, hard-code the light's position in our scene
                        vec3 light_position = vec3(2.0, -5.0, 3.0);

                        // Calculate the unit direction vector that points from
                        // the point of intersecion to the light source
                        vec3 direction_to_light = normalize(current_position - light_position);

                        float diffuse_intensity = max(0.0, dot(normal, direction_to_light));

                        return vec3(1.0, 0.0, 0.0) * diffuse_intensity;

                        // Remember, each component of the normal will be in 
                        // the range -1..1, so for the purposes of visualizing
                        // it as an RGB color, let's remap ti to the range 
                        // 0..1                    
                        //return normal * 0.5 + 0.5;
                    }

                    if (total_distance_traveled > MAXIMUM_TRACE_DISTANCE)
                    {
                        break;
                    }

                    total_distance_traveled += distance_to_closest;
                }

                return vec3(1.0);
            }

            vec3 debug()
            {
                return vec3(0.0, 1.0, 0.0);
            }

            void main()
            {
                vec2 uv = (gl_FragCoord.xy/u_resolution)*2.0 - 1.0;
                vec2 uv_aux = (gl_FragCoord.xy/u_resolution);
                // TODO UV

                vec3 camera_position = vec3(0.0, 0.0, -2.0);
                vec3 ro = camera_position;
                vec3 rd = vec3(uv, 1.0);

                vec3 shaded_color = ray_march(ro, rd);
                //shaded_color = debug();

                gl_FragColor = vec4(shaded_color, 1.0);
            }

        </script>




        <script id="shader-vs" type="x-shader/x-vertex">
            attribute vec3 aVertexPosition;

            uniform mat4 uMVMatrix;
            uniform mat4 uPMatrix;

            void main(void) {
                gl_Position = vec4(aVertexPosition, 1.0);
            }
        </script>

        <script type="text/javascript">
            var lastTime = 0;

            /*
                gl is the WebGL context. Once we got the context, we again use JavaScript's
                willingness to allow up to set any property we like on any object to store on it
                the width and height of the canvas to which it relates.
            */
            var gl;
            var canvas;
            var elapsed;
            var color = 0.5;
            var timeStart = 0;
            var frequency = 0.5;
            var multiFrequency = vec3.create();
            multiFrequency.x = 0.5;
            multiFrequency.y = 0.1;
            multiFrequency.z = 2.0;
            var mouse = {};
            mouse.x = 0.0;
            mouse.y = 0.0;


            function initGL(canvas) {
                try {
                    gl = canvas.getContext("experimental-webgl");
                    gl.viewportWidth = canvas.width;
                    gl.viewportHeight = canvas.height;
                } catch(e)
                {
                }
                if (!gl)
                {
                    alert("Could not initialise WebGL, sorry :-(");
                }
            }

            /*
                We are looking for an element in our HTML page that has an Id that matches a
                parameter passed in, pulling out its contents, creating either a fragment or a
                vertex shader based on it's type. And then passing it off to WebGL to be compiled into
                a form that can run on the graphicss card. The code then handles any errors.
            */

            function getShader(gl, id)
            {
                var shaderScript = document.getElementById(id);
                if (!shaderScript)
                {
                    return null;
                }

                var str = "";
                var k = shaderScript.firstChild;
                while (k)
                {
                    if (k.nodeType == 3)
                    {
                        str += k.textContent;
                    }
                    k = k.nextSibling;
                }

                var shader;
                if (shaderScript.type == "x-shader/x-fragment")
                {
                    shader = gl.createShader(gl.FRAGMENT_SHADER);
                } else if (shaderScript.type == "x-shader/x-vertex")
                {
                    shader = gl.createShader(gl.VERTEX_SHADER);
                } else
                {
                    return null;
                }

                gl.shaderSource(shader, str);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
                {
                    alert(gl.getShaderInfoLog(shader));
                    return null;
                }

                return shader;
            }

            /*
                This initializes the shaders
            */

            var shaderProgram;

            function initShaders()
            {
                /*
                    Gets twi things, a "fragment shader" and a "vertex shader"
                    and then attaches them both to a WebGL thing called a "program"
                    A program is a bit of code that lives on the WebGL side of the system.
                    Ypu can associate with it a number of shaders, each of which you can see as
                    a snippet of code within that program; specifically each program can hold one
                    fragment and one vertex shader.
                */
                var fragmentShader = getShader(gl, "shader-fs-raymarching");
                var vertexShader = getShader(gl, "shader-vs");

                shaderProgram = gl.createProgram();
                gl.attachShader(shaderProgram, vertexShader);
                gl.attachShader(shaderProgram, fragmentShader);
                gl.linkProgram(shaderProgram);

                if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                    alert("Could not initialise shaders");
                }

                gl.useProgram(shaderProgram);
                /*
                    Gets the reference to an "attribute", which its stores in a new field on
                    the program object called vertexPositionAttribute
                */
                shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
                gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

                shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
                shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
                shaderProgram.elapsed_time = gl.getUniformLocation(shaderProgram, "u_time");
                shaderProgram.frequency = gl.getUniformLocation(shaderProgram, "frequency");
                shaderProgram.multiFrequency = gl.getUniformLocation(shaderProgram, "multiFrequency");


            }

            var mvMatrix = mat4.create();
            var pMatrix = mat4.create();

            /*
                Gets the locations of two things called uniform variables.
                Like the attribute we store them on the program object for convenience.
                Using the references to the uniforms that represent our projection matrix
                and our model-view matrix that we got back in initShaders, we send WebGL the
                values from out JavaScript-style matrices.
            */

            function setMatrixUniforms() {
                gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
                gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
            }

            function setUniforms() {
                gl.uniform1f(shaderProgram.elapsed_time, elapsed);
                //gl.uniform1f(shaderProgram.frequency, frequency);
                //gl.uniform3f(shaderProgram.multiFrequency, multiFrequency.x, multiFrequency.y, multiFrequency.z);
                gl.uniform2f(gl.getUniformLocation(shaderProgram, "u_resolution"), gl.viewportWidth, gl.viewportHeight);
                gl.uniform2f(gl.getUniformLocation(shaderProgram, "u_mouse"), mouse.x, mouse.y);
            }

            var squareVertexPositionBuffer;

            function initBuffers()
            {
                squareVertexPositionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
                vertices = [
                    1.0, 1.0, 0.0,
                    -1.0, 1.0, 0.0,
                    1.0, -1.0, 0.0,
                    -1.0, -1.0, 0.0
                ];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
                squareVertexPositionBuffer.itemSize = 3;
                squareVertexPositionBuffer.numItems = 4;
            }

            /*
                Now what we need to do to push our two objects vertex positions up to the graphics card.
                In drawScene we use those buffers to actually draw the image we are seeing
            */

            function drawScene()
            {
                gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
               
                setUniforms();               
                gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, squareVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.drawArrays(gl.TRIANGLE_STRIP, 0, squareVertexPositionBuffer.numItems);
            }

            /*
                This function calls functions to initialise WebGL and the shaders. Also it initialises
                some buffers using initBuffers; buffers are things that hod you the details of the triangle
                and the square that we are going to be drawing. Then it does some basic WebGL setups, saying
                that when we clear the canvas we should make it black, and that we should do depth testing
                (s0 that things drawn begind other things should be hidden by the thifs in front of them) These steps
                are implemented by calls to methods on a gl object. Finally it calls the function drawScene, this draws
                the triangle and the square using the buffers
            */

            function tick() {
                requestAnimFrame(tick);
                //window.setInterval(tick, 1);
                drawScene();
                clock();
            }

            function clock() 
            {
                var timeNow = new Date().getTime();
                //timeNow = timeNow * 2*Math.PI;
               //console.log(timeNow);
                if (time_start != 0)
                {
                    //console.log("DEBUG: " + ((timeNow - lastTime)/20000 ))
                    elapsed = timeNow - time_start;
                    var aux = elapsed / 1000;
                    //console.log("AUX: "+ aux);

                    elapsed = elapsed / 20000;
                    elapsed = aux;


                    //console.log(elapsed);
                }
                lastTime = timeNow;
            }

            function convertToDeviceCoords() {
                mouse.x = (mouse.x / gl.viewportWidth);
                var aux = -1 * ((mouse.y / gl.viewportHeight) - 1);
                if ( aux < 0) {
                    mouse.y = 0;
                } else { 
                    mouse.y = aux;
                }
            }

            function handleMouse(event) {
                mouse.x = event.pageX;
                mouse.y = event.pageY;
                convertToDeviceCoords();
                console.log("x: "+mouse.x);
                console.log("y: "+mouse.y);

            }

            function webGLStart()
            {
                canvas = document.getElementById("shaderlab-canvas");
                initGL(canvas);
                initShaders();
                initBuffers();

                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                gl.enable(gl.DEPTH_TEST);

                time_start = new Date().getTime();

                canvas.onmousemove =  handleMouse;

                tick();                
            }

            function sayHello()
            {
                console.log("HELLO WORLD!");
            }




        </script>
    </head>
    <!--
        HTML code, with Canvas element for rendering the webgl 3D content
        CANVAS SIZE: 700 x 430
    -->
    <body onload="webGLStart();" style="background-color:#E6E6FA">
        <canvas id="shaderlab-canvas" style="border: none;" width="700" height="700"></canvas>
    </body>

</html>
