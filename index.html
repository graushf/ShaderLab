<html>
    <head>
        <title>ShaderLab</title>
        <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
        <script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>

        <!--
            These shaders are not written in JavaScript, even thought the ancestry
            of the language is clearly similar. They are written in a special shader
            language called GLSL, that owes a lot to C (as of course, does JavaScript)
        -->

        <!--
            The fragment shader, does pretty much nothing, it has a bit of obligatory
            boilerplate code to tell the graphidcs card how precise we want it to be with
            floating point numbers (medium prpecision is good because it's required to
            be supported by all WebGL devices - highp for high precision doesn't work on
            all mobile devices) then simply specifies that everything that is drawn will be
            drawn in white.
        -->
        <script id="shader=fs" type="x-shader/x-fragment">
            precision mediump float;

            void main(void) {
                gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
            }
        </script>
        <!--
            The vertex shader is more interesting. Means that it's a bit of graphics card
            code that can do pretty much anything it wants with a vertex.
            Associated with it has two uniform variables called uMVMatrix and uPMatrix.
            Uniform variables are useful because they can be accessed from outside the
            shader
        -->
        <script id="shader-vs" type="x-shader/x-vertex">
            attribute vec3 aVertexPosition;

            uniform mat4 uMVMatrix;
            uniform mat4 uPMatrix;

            void main(void) {
                gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
            }
        </script>

        <script type="text/javascript">
            /*
                gl is the WebGL context. Once we got the context, we again use JavaScript's
                willingness to allow up to set any property we like on any object to store on it
                the width and height of the canvas to which it relates.
            */
            var gl;
            function initGL(canvas) {
                try {
                    gl = canvas.getContext("experimenta-webgl");
                    gl.viewportWidth = canvas.width;
                    gl.viewportHeight = canvas.height;
                } catch(e)
                {
                }
                if (!gl)
                {
                    alert("Could not initialise WebGL, sorry :-(");
                }
            }

            /*
                We are looking for an element in our HTML page that has an Id that matches a
                parameter passed in, pulling out its contents, creating either a fragment or a
                vertex shader based on it's type. And then passing it off to WebGL to be compiled into
                a form that can run on the graphicss card. The code then handles any errors.
            */

            function getShader(gl, id)
            {
                var shaderScript = document.getElementById(id);
                if (!shaderScript)
                {
                    return null;
                }

                var str = "";
                var k = shaderScript.firstChild;
                while (k)
                {
                    if (k.nodeType == 3)
                    {
                        str += k.textContent;
                    }
                    k = k.nextSibling;
                }

                var shader;
                if (shaderScript.type == "x-shader/x-fragment")
                {
                    shader = gl.createShader(gl.FRAGMENT_SHADER);
                } else if (shaderScript.type == "x-shader/x-fragment")
                {
                    shader = gl.createShader(gl.VERTEX_SHADER);
                } else
                {
                    return null;
                }

                gl.shaderSource(shader, str);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
                {
                    alert(gl.getShaderInfoLog(shader));
                    return null;
                }

                return shader;
            }

            /*
                This initializes the shaders
            */

            var shaderProgram;

            function initShaders()
            {
                /*
                    Gets twi things, a "fragment shader" and a "vertex shader"
                    and then attaches them both to a WebGL thing called a "program"
                    A program is a bit of code that lives on the WebGL side of the system.
                    Ypu can associate with it a number of shaders, each of which you can see as
                    a snippet of code within that program; specifically each program can hold one
                    fragment and one vertex shader.
                */
                var fragmentShader = getShader(gl, "shader-fs");
                var vertexShader = getShader(gl, "shader-vs");

                shaderProgram = gl.createProgram();
                gl.attachShader(shaderProgram, vertexShader);
                gl.attachShader(shaderProgram, fragmentShader);
                gl.linkProgram(shaderProgram);

                if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                    alert("Could not initialise shaders");
                }

                gl.useProgram(shaderProgram);
                /*
                    Gets the reference to an "attribute", which its stores in a new field on
                    the program object called vertexPositionAttribute
                */
                shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
                gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

                shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
                shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
            }

            var mvMatrix = mat4.create();
            var pMatrix = mat4.create();

            /*
                Gets the locations of two things called uniform variables.
                Like the attribute we store them on the program object for convenience.
                Using the references to the uniforms that represent our projection matrix
                and our model-view matrix that we got back in initShaders, we send WebGL the
                values from out JavaScript-style matrices.
            */

            function setMatrixUniforms() {
                gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
                gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
            }

            /*
                Two global variables to hold the buffers
            */
            var triangleVertexPositionBuffer;
            var squareVertexPositionBuffer;

            function initBuffers()
            {
                /*
                    We create a buffer for the triangle's vertex positions. This
                    buffer is actually a bit of memory on the graphics card by putting
                    the vertex positions on the card once in our initialisation code and then,
                    when we come to draw the scene, essentially telling WebGL to "draw those things
                    that I told you earlier"

                */
                triangleVertexPositionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);

                /*
                    We define our vertex positions as JavaScript list
                */
                var vertices = [
                    0.0, 1.0, 0.0,
                    -1.0, -1.0, 0.0,
                    1.0, -1.0, 0.0
                ];

                /*
                    We create a Float32Array object based on our JavaScript list,
                    and tell WebGL to use it to fill the current buffer, which is
                    triangleVertexPositionBuffer, Float32Arrays are a way of turning
                    a JavaScript list into something we can pass over to WebGL for filling
                    its buffers
                */

                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

                /*
                    Set two new properties to the buffers, these are useful later on.
                */

                triangleVertexPositionBuffer.itemSize = 3;
                triangleVertexPositionBuffer.numItems = 3;

                squareVertexPositionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
                vertices = [
                    1.0, 1.0, 0.0,
                    -1.0, 1.0, 0.0,
                    1.0, -1.0, 0.0,
                    -1.0, -1.0, 0.0
                ];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
                squareVertexPositionBuffer.itemSize = 3;
                squareVertexPositionBuffer.numItems = 4;
            }

            /*
                Now what we need to do to push our two objects vertex positions up to the graphics card.
                In drawScene we use those buffers to actually draw the image we are seeing
            */

            function drawScene()
            {
                /*
                    Tell WebGL a bit about the size of the canvas using the  viewport function, This
                    function needs calling with the size of the canvas before you start drawing.
                */
                gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
                /*
                    We clear the canvas in preparation for drawing on it.
                */
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                /*
                    Here we are setting up the perspective with which we want to view the scene
                    By default WebGL uses ortographic projection. In order to make things that are
                    further away look smaller, we need to tell it a little about the perspective we're
                    usign . For this scene, we're saying that our vertical field of view is 45 degrees,
                    we are telling it about the width-to-height ratio of our canvas, and saying that we don't
                    want to see things that are closer than 0.1 units to our viewport. And that we don't want
                    to see units farther away than 100 units.
                    This perspective stuff is using a function from a module called mat4, and involves pMatrix
                */
                mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
                /*
                    First step of drawing, move to the center of the 3D scene.
                */
                mat4.identity(mvMatrix);
                // Code that draws the triangle on the left hand side of the canvas.
                mat4.translate(mvMatrix, [-1.5, 0.0, -7.0]);
                /*
                    So, you remember that in order to use one of our buffers, we call gl.bindBuffer to specify a
                    current buffer, and the cal the code that operated on it. Here we-re selecting our
                    triangleVertexPositionBuffer, then telling WebGL that the values in it should be used for
                    vertex positions. For now you can see that we are using the itemSize property we set on the buffer
                    to tell WebGL that each item in the buffer is three numbers long
                */

                gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
                /*
                    This tells WebGL to take account of our current model-view matrix. This is required because all of this matrix stuff isn't
                    built in to WebGL. You can do all of the moving around by changing the mvMatrix variable you want, but this all happens
                    in JavaScript private space. setMatrixUniforms, moves it over to the graphics card.
                */
                setMatrixUniforms();

                gl.drawArrays(gl.TRIANGLES, 0, triangleVertexPositionBuffer.numItems);

                /*
                    Draw the square.
                    Move the modelview matrix three units to the right.
                */
                mat4.translate(mvMatrix, [3.0, 0.0, 0.0]);
                // We tell WebGL  to use our square's buffer for its vertex positions
                gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, squareVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
                // We push over the model-view matrix and projection matrices again.
                setMatrixUniforms();

                gl.drawArrays(gl.TRIANGLE_STRIP, 0, squareVertexPositionBuffer.numItems);
            }

            /*
                This function calls functions to initialise WebGL and the shaders. Also it initialises
                some buffers using initBuffers; buffers are things that hod you the details of the triangle
                and the square that we are going to be drawing. Then it does some basic WebGL setups, saying
                that when we clear the canvas we should make it black, and that we should do depth testing
                (s0 that things drawn begind other things should be hidden by the thifs in front of them) These steps
                are implemented by calls to methods on a gl object. Finally it calls the function drawScene, this draws
                the triangle and the square using the buffers
            */

            function webGLStart()
            {
                var canvas = document.getElementById("shaderlab-canvas");
                initGL(canvas);
                initShaders();
                initBuffers();

                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                gl.enable(gl.DEPTH_TEST);

                drawScene();
            }

        </script>
    </head>
    <!--
        HTML code, with Canvas element for rendering the webgl 3D content
    -->
    <body>
        <canvas id="shaderlab-canvas" style="border: none;" width="500" height="500"></canvas>
    </body>

</html>
